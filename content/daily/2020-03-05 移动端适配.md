---
title: "移动端适配"
date: 2020-03-05T10:47:01+08:00
draft: false
---

## 相关单位概念

- px: 根据屏幕分辨率而言的，是`绝对长度单位`，它不会根据屏幕的大小进行调整。
    - 设备像素比：DPR = 设备分辨率/设备屏幕宽度；`window.devicePixelRatio = document.body.clientWidth / window.screen.width;`
- em: 是相`对字体长度单位`。如果用于font-size属性本身，则是相对于父元素的font-size。
    - 如果父级没设置，则相对于浏览器默认字体大小16px。即1em = 16px
    - em的值并不是固定的。
    - em会继承父级元素的字体大小。
- rem: root em 是相对html的font-size
    - 为了简化font-size的换算，一般在css中的根元素html中声明font-size=62.5%，这就使rem值变为16px*62.5%=10px,即1rem = 10px。方便后续计算。
- vh: 1vh = 1%height,所以一般100vh表示整个屏幕的高度
- vw: 1vh = 1%width,所以一般100vh表示整个屏幕的宽度

## 移动端适配的几种方案：

### rem方案
```js
(function PageResize(){
	(function getResize(){
		var width=window.innerWidth||window.documentElement.clientWidth||window.body.clientWidth;
		width>750?width=750:null;
		width<320?width=320:null;
		document.documentElement.style.fontSize=(width*(100/750))+'px';
		if(!window.onresize){
			window.onresize=function(){
				delayFunc(getResize);
			}
		}
	})()
// 延迟计算加个延迟是为了 当窗口发现变化 页面不是瞬间变化 有个变化的延迟 用户体验更好 
	var timer;
	var delayFunc=function(fn){
		var delay=300;// 根据实际情况可调整延迟时间
		// 这里延时执行你的函数
		timer=setTimeout(function(){
			fn();
		},delay);
	};
})();

```
- 优点
    - 自适应好
    - 兼容性好
- 缺点
    - 需要引入js脚本不是纯css适配，且该js脚本还需要前置在css样式前。
    - 需要监听窗口变化去改变根元素的字体大小
    - 小像素的精度问题。比如换算之后为 `0.625px`，其渲染尺寸会变成`1px`；换算之后为 `0.325px`会渲染成`0`。所以遇到一些小像素的可以不进行转换。
  
### vw/vh方案

- 优点：
    - 纯css移动端适配方案，不存在脚本依赖的问题
    - 根据视口宽度的百分比来定义元素宽度，计算方便；
- 缺点
    - 兼容性：Ios8及Android4.4以上支持

### rem+vw方案

设置html元素的font-size单位为vw，然后在布局中直接使用rem单位。

```css
/* 假设设计稿的宽度为750px，则1vw=7.5px，为了方便计算，我们将html元素的font-size大小设置为100px，也就是13.333vw=100px。 */
html{
  font-size:13.333vw
}
```

###  百分比

- 优点 无兼容性问题
- 缺点
    - 字体大小无法随着屏幕大小变化而改变
    - 设置盒模型的不同属性时，其百分比设置的参考元素不唯一，容易使布局问题变得复杂。

### 基于媒体查询的响应式设计

```css
@media only screen and (min-width: 375px){
    /*样式1*/
}
@media only screen and (min-width: 750px){
    /*样式2*/
}
```

- 优点
    - 能够使网页在不同设备、不同分辨率的屏幕上呈现合理布局，不单单是样式伸缩变换。
- 缺点
    - 如果要匹配很多的设备与屏幕，需要写很多适配代码，工作量比较大。
    - 会设置一定量的断点，到达某个断点前后的页面发生突兀变化，用户体验不太友好。


[代码参考](https://blog.csdn.net/yunchong_zhao/article/details/105556533)